name: Convert Markdown to PDF

on:
  push:
    branches: [main, master]
    paths:
      - "**/*.md"
      - ".github/config/styles/**"
  workflow_dispatch:

jobs:
  convert-to-pdf:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            pandoc \
            weasyprint \
            fonts-noto \
            fonts-noto-cjk \
            fonts-noto-color-emoji \
            fonts-firacode

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Convert Markdown to PDF
        run: |
          set -e
          
          CONFIG_FILE=".github/config/md-to-pdf-config.yml"
          
          if [[ ! -f "$CONFIG_FILE" ]]; then
            echo "‚ùå Config file not found: $CONFIG_FILE"
            exit 1
          fi
          
          # Read global config
          OUTPUT_DIR=$(yq '.output_dir // "output"' "$CONFIG_FILE")
          CSS_FILE=$(yq '.css_file // ".github/config/styles/print.css"' "$CONFIG_FILE")
          
          echo "üìÅ Output directory: $OUTPUT_DIR"
          echo "üé® CSS file: $CSS_FILE"
          
          mkdir -p "$OUTPUT_DIR"
          
          # Preprocessing function
          preprocess() {
            cat "$1" | \
            sed 's/%%[^%]*%%//g' | \
            sed 's/==\([^=]*\)==/<mark>\1<\/mark>/g' | \
            sed 's/\[\[\([^]|]*\)\]\]/**\1**/g' | \
            sed 's/\[\[[^]|]*|\([^]]*\)\]\]/**\1**/g' | \
            sed 's/!\[\[\([^]]*\)\]\]/[üìé \1]/g' | \
            sed 's/^> \[!note\].*/> üìù **Note**/g' | \
            sed 's/^> \[!info\].*/> ‚ÑπÔ∏è **Info**/g' | \
            sed 's/^> \[!tip\].*/> üí° **Tip**/g' | \
            sed 's/^> \[!warning\].*/> ‚ö†Ô∏è **Warning**/g' | \
            sed 's/^> \[!danger\].*/> üö® **Danger**/g' | \
            sed 's/^> \[!example\].*/> üìå **Example**/g' | \
            sed 's/^> \[!question\].*/> ‚ùì **Question**/g' | \
            sed 's/^> \[!success\].*/> ‚úÖ **Success**/g' | \
            sed 's/^> \[!failure\].*/> ‚ùå **Failure**/g' | \
            sed 's/^> \[!bug\].*/> üêõ **Bug**/g' | \
            sed 's/^> \[!quote\].*/> üí¨ **Quote**/g' | \
            sed 's/^> \[!todo\].*/> ‚òê **Todo**/g' | \
            sed 's/^> \[!important\].*/> üî• **Important**/g'
          }
          
          get_base_path() {
            echo "$1" | sed 's/\*.*$//' | sed 's:/$::'
          }
          
          convert_file() {
            local file="$1"
            local preserve_full_path="$2"
            local base_path="$3"
            local output_path
            local dir_path
            local filename
            
            filename=$(basename "$file" .md)
            
            if [[ "$preserve_full_path" == "true" ]]; then
              dir_path=$(dirname "$file")
              output_path="$OUTPUT_DIR/$dir_path"
            else
              local rel_path="${file#$base_path/}"
              dir_path=$(dirname "$rel_path")
              if [[ "$dir_path" == "." ]]; then
                output_path="$OUTPUT_DIR"
              else
                output_path="$OUTPUT_DIR/$dir_path"
              fi
            fi
            
            mkdir -p "$output_path"
            
            echo "üìÑ Converting: $file"
            echo "   Output: $output_path/$filename.pdf"
            
            if preprocess "$file" | pandoc \
              -o "$output_path/$filename.pdf" \
              --pdf-engine=weasyprint \
              --css="$CSS_FILE" \
              --wrap=none \
              --standalone \
              --resource-path="$(dirname "$file")" \
              2>&1; then
              echo "   ‚úÖ Success"
            else
              echo "   ‚ö†Ô∏è Failed: $file"
            fi
          }
          
          SOURCE_COUNT=$(yq '.sources | length' "$CONFIG_FILE")
          echo "üìö Found $SOURCE_COUNT source(s) in config"
          echo ""
          
          for i in $(seq 0 $((SOURCE_COUNT - 1))); do
            GLOB=$(yq ".sources[$i].glob" "$CONFIG_FILE")
            PRESERVE_FULL_PATH=$(yq ".sources[$i].preserve_full_path // false" "$CONFIG_FILE")
            ENABLED=$(yq ".sources[$i].enabled // true" "$CONFIG_FILE")
            
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìÇ Source $((i + 1)): $GLOB"
            echo "   preserve_full_path: $PRESERVE_FULL_PATH"
            
            if [[ "$ENABLED" != "true" ]]; then
              echo "   ‚è≠Ô∏è Skipping (disabled)"
              continue
            fi
            
            BASE_PATH=$(get_base_path "$GLOB")
            
            shopt -s globstar nullglob
            files=( $GLOB )
            shopt -u globstar nullglob
            
            if [[ ${#files[@]} -eq 0 ]]; then
              echo "   ‚ö†Ô∏è No files found"
              continue
            fi
            
            echo "   Found ${#files[@]} file(s)"
            
            for file in "${files[@]}"; do
              if [[ -f "$file" ]]; then
                convert_file "$file" "$PRESERVE_FULL_PATH" "$BASE_PATH"
              fi
            done
          done
          
          echo ""
          echo "‚úÖ Conversion complete!"

      - name: Commit and push PDFs
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -f output/
          git diff --quiet && git diff --staged --quiet || (git commit -m "üìÑ Auto-generate PDFs [skip ci]" && git push)