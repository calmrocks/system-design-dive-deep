name: Convert Markdown to PDF

on:
  push:
    branches: [main, master]
    paths:
      - "**/*.md"
      - ".github/workflows/md-to-pdf-config.yml"
      - ".github/styles/**"
  workflow_dispatch:

jobs:
  convert-to-pdf:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            pandoc \
            weasyprint \
            fonts-noto \
            fonts-noto-cjk \
            fonts-noto-color-emoji \
            fonts-firacode

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Convert Markdown to PDF
        run: |
          set -e
          
          CONFIG_FILE=".github/workflows/md-to-pdf-config.yml"
          
          # Check if config file exists
          if [[ ! -f "$CONFIG_FILE" ]]; then
            echo "âŒ Config file not found: $CONFIG_FILE"
            exit 1
          fi
          
          # Read global config with defaults
          OUTPUT_DIR=$(yq '.output_dir // "output"' "$CONFIG_FILE")
          CSS_FILE=$(yq '.css_file // ".github/styles/print.css"' "$CONFIG_FILE")
          
          echo "ğŸ“ Output directory: $OUTPUT_DIR"
          echo "ğŸ¨ CSS file: $CSS_FILE"
          
          # Create output directory
          mkdir -p "$OUTPUT_DIR"
          
          # Preprocessing function for Obsidian syntax
          preprocess() {
            cat "$1" | \
            # Remove Obsidian comments
            sed 's/%%[^%]*%%//g' | \
            # Convert ==highlight== to <mark>
            sed 's/==\([^=]*\)==/<mark>\1<\/mark>/g' | \
            # Convert [[wikilink]]
            sed 's/\[\[\([^]|]*\)\]\]/**\1**/g' | \
            # Convert [[wikilink|display]]
            sed 's/\[\[[^]|]*|\([^]]*\)\]\]/**\1**/g' | \
            # Convert ![[embed]]
            sed 's/!\[\[\([^]]*\)\]\]/[ğŸ“ \1]/g' | \
            # Convert callouts
            sed 's/^> \[!note\].*/> ğŸ“ **Note**/g' | \
            sed 's/^> \[!info\].*/> â„¹ï¸ **Info**/g' | \
            sed 's/^> \[!tip\].*/> ğŸ’¡ **Tip**/g' | \
            sed 's/^> \[!warning\].*/> âš ï¸ **Warning**/g' | \
            sed 's/^> \[!danger\].*/> ğŸš¨ **Danger**/g' | \
            sed 's/^> \[!example\].*/> ğŸ“Œ **Example**/g' | \
            sed 's/^> \[!question\].*/> â“ **Question**/g' | \
            sed 's/^> \[!success\].*/> âœ… **Success**/g' | \
            sed 's/^> \[!failure\].*/> âŒ **Failure**/g' | \
            sed 's/^> \[!bug\].*/> ğŸ› **Bug**/g' | \
            sed 's/^> \[!quote\].*/> ğŸ’¬ **Quote**/g' | \
            sed 's/^> \[!todo\].*/> â˜ **Todo**/g' | \
            sed 's/^> \[!important\].*/> ğŸ”¥ **Important**/g'
          }
          
          # Function to extract base path from glob pattern
          # e.g., "Books/**/*.md" -> "Books"
          get_base_path() {
            local glob="$1"
            # Extract everything before the first wildcard
            echo "$glob" | sed 's/\*.*$//' | sed 's:/$::'
          }
          
          # Function to convert a single file
          convert_file() {
            local file="$1"
            local preserve_full_path="$2"
            local base_path="$3"
            local output_path
            local dir_path
            local filename
            
            filename=$(basename "$file" .md)
            
            if [[ "$preserve_full_path" == "true" ]]; then
              # Keep full path: Books/a/b.md -> output/Books/a/b.pdf
              dir_path=$(dirname "$file")
              output_path="$OUTPUT_DIR/$dir_path"
            else
              # Strip base path: Books/a/b.md -> output/a/b.pdf
              local rel_path="${file#$base_path/}"
              dir_path=$(dirname "$rel_path")
              if [[ "$dir_path" == "." ]]; then
                output_path="$OUTPUT_DIR"
              else
                output_path="$OUTPUT_DIR/$dir_path"
              fi
            fi
            
            mkdir -p "$output_path"
            
            echo "ğŸ“„ Converting: $file"
            echo "   Output: $output_path/$filename.pdf"
            
            # Preprocess and convert
            if preprocess "$file" | pandoc \
              -o "$output_path/$filename.pdf" \
              --pdf-engine=weasyprint \
              --css="$CSS_FILE" \
              --wrap=none \
              --standalone \
              --resource-path="$(dirname "$file")" \
              2>&1; then
              echo "   âœ… Success"
            else
              echo "   âš ï¸ Failed: $file"
            fi
          }
          
          # Get number of sources
          SOURCE_COUNT=$(yq '.sources | length' "$CONFIG_FILE")
          echo "ğŸ“š Found $SOURCE_COUNT source(s) in config"
          echo ""
          
          # Process each source
          for i in $(seq 0 $((SOURCE_COUNT - 1))); do
            GLOB=$(yq ".sources[$i].glob" "$CONFIG_FILE")
            PRESERVE_FULL_PATH=$(yq ".sources[$i].preserve_full_path // false" "$CONFIG_FILE")
            ENABLED=$(yq ".sources[$i].enabled // true" "$CONFIG_FILE")
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“‚ Source $((i + 1)): $GLOB"
            echo "   preserve_full_path: $PRESERVE_FULL_PATH"
            echo "   enabled: $ENABLED"
            
            # Skip if disabled
            if [[ "$ENABLED" != "true" ]]; then
              echo "   â­ï¸ Skipping (disabled)"
              continue
            fi
            
            # Get base path for stripping
            BASE_PATH=$(get_base_path "$GLOB")
            echo "   base_path: $BASE_PATH"
            echo ""
            
            # Find and convert files matching the glob
            # Use eval to expand the glob pattern
            shopt -s globstar nullglob
            files=( $GLOB )
            shopt -u globstar nullglob
            
            if [[ ${#files[@]} -eq 0 ]]; then
              echo "   âš ï¸ No files found matching pattern"
              continue
            fi
            
            echo "   Found ${#files[@]} file(s)"
            echo ""
            
            for file in "${files[@]}"; do
              if [[ -f "$file" ]]; then
                convert_file "$file" "$PRESERVE_FULL_PATH" "$BASE_PATH"
              fi
            done
          done
          
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Conversion complete!"

      - name: List generated PDFs
        run: |
          echo "ğŸ“‹ Generated PDFs:"
          find output -name "*.pdf" -type f | sort | while read f; do
            echo "   $f"
          done

      - name: Commit and push PDFs
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -f output/
          git diff --quiet && git diff --staged --quiet || (git commit -m "ğŸ“„ Auto-generate PDFs [skip ci]" && git push)